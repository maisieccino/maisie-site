---
import type {MarkdownHeading} from "astro"
import styles from "./sidebar.module.css"

const { headings, isBlog }: {headings?: MarkdownHeading[]; isBlog?: boolean} = Astro.props;
---
<script>
const listener = () => {
  const navLinks = document.querySelectorAll("#sidebar-nav a");
  if (navLinks === undefined) {
    return
  }
  const content = document.querySelector("#page-container")
  const headers = Array.from(content?.querySelectorAll("h1, h2, h3") || [])
  if (headers.length == 0) {
    return
  }

  let mostRecent: Element|null = null;

  const visibleHeadings = new Set<Element>();
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(e => {
      if (e.isIntersecting) {
        visibleHeadings.add(e.target)
      } else {
        visibleHeadings.delete(e.target)
      }

      // Sort descending by appearance.
      const latestVisible = Array.from(visibleHeadings.values())
        .sort((a,b) => headers.indexOf(b) - headers.indexOf(a))[0]

      // Lil hack here. If the section is bigger than the viewport and we can't
      // see the heading anymore, revert to the most recently seen.
      if (latestVisible !== undefined) {
        mostRecent = latestVisible
      }

      headers?.forEach(h => {
        const [ _, link ] = navLinks.entries().find(([_, l]) => l.id === `nav-${h.id}`) || []
        const val = h === mostRecent ? "active" : (
          visibleHeadings.has(h) ? "visible" : ""
        )
        link?.setAttribute("attr-active", val)
      })
    })
  })
  headers?.forEach(h => observer.observe(h))
}
document.addEventListener('astro:page-load', listener)
</script>
<aside class={styles.sidebar} id="sidebar-nav">
  <h3>Contents</h3>
  <slot />
<a href="#top"><b>Top</b></a>
    {headings && headings.map((h) => {
      const style = {
      paddingLeft: `${h.depth * 0.5}rem`,
    }
return <a id={`nav-${h.slug}`} href={`#${h.slug}`} style={style}>{h.text}</a>
    })}
  {isBlog && 
  <a href="/blog">â€¹ <b>Back to index</b></a>}
</aside>
